# BOJ1202: 보석 도둑
[BOJ1202](https://www.acmicpc.net/problem/1202) 키워드: [`#그리디`](greedy.md), [`#우선순위큐`](priority_queue.md)
### 문제 요약
> N개의 보석이 있고, 상덕이는 가방 K개를 가지고 있을 때, 상덕이가 훔칠 수 있는 보석의 최대 가격

## 처음에 생각한 방법
가벼운 가방이 자기가 가져갈 수 있는 보석 중에 제일 비싼 거 가져가면 된다
1. 보석 비싼 순으로 정렬
2. 가방 가벼운 순으로 정렬
3. 가방이 비싼 보석부터 순회하며 가방안에 들어갈 수 있다면 take, 그 보석 배열에서 out

### 문제점
모든 가방이 매번 남아있는 보석 중에 제일 비싼 것부터 순회함.(이전 가방이 순회한 것을 또 순회함)
- 최대 O(NK) 시간복잡도
- 당연히 시간초과

## 해결 과정
>  나보다 가벼운 가방이 들고 갈 수 있는 보석은 나도 들고 갈 수 있음. </br>
>   그럼 순회하면서 들고 갈 수 있는 보석들을 `새로운 가방`에 싹다 집어넣고, </br>
>    항상 그 중 가장 비싼 거 가져가면 된다.

새로운 가방 == 우선순위 큐

1. 보석 오름차순으로 정렬
2. 가방 오름차순으로 정렬
3. 가벼운 가방부터 for문 돌면서
   1. 현재 가방보다 가벼운 보석들 모두 우선순위 큐에 넣기
   2. 현재 가방보다 무거운 보석을 만나면, 루트노드(지금 무게 이하 보석에서 가장 비싼 보석) 꺼내기
4. 3번 반복

## 코드
[풀이](https://github.com/seojeewon/Algorithm-Study/blob/main/greedy/BOJ1202.cpp)


참고: [인프런 10주완성 C++ 코딩테스트](https://www.inflearn.com/course/10%EC%A3%BC%EC%99%84%EC%84%B1-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%81%B0%EB%8F%8C/dashboard)