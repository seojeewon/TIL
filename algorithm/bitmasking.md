# 비트마스킹
bit = binary digit
## 비트 연산자
|    |                     |                    |   |   |   |   |   |   |   |
|----|---------------------|--------------------|---|---|---|---|---|---|---|
| `&`  | AND                 | 1000 & 1001 = 1000 |   |   |   |   |   |   |   |
| `\|`  | OR                  | 1000 \| 1001 = 1001 |   |   |   |   |   |   |   |
| `^`  | XOR                 | 1000 ^ 1001 = 0001 |   |   |   |   |   |   |   |
| `~`  | 모든 비트 반전            | ~1000 = 0111       |   |   |   |   |   |   |   |
| `<<` | left logical shift  | 111 << 1 = 1110    |   |   |   |   |   |   |   |
| `>>` | right logical shift | 111 >> 1 = 11      |   |   |   |   |   |   |   |
|    |                     |                    |   |   |   |   |   |   |   |


$a<<b = a*2^b$ </br>
$a>>b = a*2^{-b}$ </br>
~$value=-(value+1)$

## 비트연산자 활용
S = 연산할 숫자
### 1. {idx}번째 비트 끄기
`S &= ~(1<<idx)`
### 2. {idx}번째 비트 XOR 연산
`S ^= (1<<idx)`
### 3. 최하위 켜져 있는 비트 알아내기
`idx = S & -S`
### 4. 크기가 n인 집합의 모든 비트 켜기
`(1<<n)-1`
### 5. {idx}번째 비트 켜기
`S |= (1<<idx)`
### 6. {idx}번째 비트가 켜져있는지 확인하기
`if(S & (1<<idx))`

## 비트마스킹은 언제 사용하는가?
`boolean 배열` 역할을 하는 `하나의 숫자`를 만들어서 비트연산자를 통해 탐색, 수정하기 위해
- 따라서 `boolean 배열`이 `31개`를 넘어가면 사용하지 않는 것이 좋다.
  - 왜냐하면 `int`는 32bit이므로

## 관련 문제
- [BOJ1285: 동전 뒤집기](prob/BOJ1285.md)

</br>

참고: [인프런 10주완성 C++ 코딩테스트](https://www.inflearn.com/course/10%EC%A3%BC%EC%99%84%EC%84%B1-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%81%B0%EB%8F%8C/dashboard)