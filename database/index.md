# 인덱싱
키워드: `#인덱스`, `#B-트리`, `#B+tree`

하드디스크나 SSD와 같은 외부 기억장치는 `블록`단위로 파일 입출력
- 따라서 하나의 블록에 여러 데이터 저장하면 효율적 사용 가능
- B-Tree 쓰는 이유

## 인덱스
튜플의 `검색속도`를 높이기 위해 (속성 값, 튜플 주소)를 `key-value` 형태로 저장

### 장점
인덱스 테이블에 데이터가 `정렬`되어 있어 검색 속도가 빠르다

### 단점
- 인덱스 테이블을 위한 저장 공간이 필요(데이터베이스와 따로 저장된다)
- 데이터를 추가, 삭제, 수정하는 연산이 많을 경우 속도가 느릴 수 있다.

### 언제 사용?
데이터 추가할 경우 재정렬

튜플을 삭제해도 인덱스 테이블에는 남아 있다.

즉, 삭제 연산이 많으면 인덱스 테이블의 크기는 일정하지만, 실제 데이터는 적어서 성능이 저하될 수 있다.

따라서 데이터 양이 방대하고 `검색`을 자주하는 경우에 인덱스를 사용하는 것이 좋다.

## B-트리
이진 트리에서 확장되어 `하나의 노드`가 `여러 자료`를 가지거나, `2개 이상의 자식노드`를 가질 수 있다.

(M차 B-트리: 최대 M개의 자식노드), (균형이진트리)
- 최악의 경우에도 `O(logN)`
- `모든 노드`가 `레코드 포인터`를 가진다.
- `리프노드`는 같은 레벨에 있다.
- `루트 노드`는 최소 2개 이상의 자식
- `리프 노드`는 최대 M개~최소 M/2개 자식

## B+트리
B-트리의 특징을 가지지만 모든 키 값이 리프 노드에 정렬되어 있다.
- `리프노드`에만 `레코드 포인터`를 가진다. 따라서 리프노드에 모든 키가 존재
- 모든 리프노드는 `연결`되어 있다.

## B*트리
B-트리는 균형을 유지하기 위해 추가적인 연산 수행하거나 노드를 생성

이를 최소화하기 위해 몇 가지 규칙을 추가한 것이 B*트리

- `루트 노드`가 아닌 노드는 적어도 2M/3개의 자식노드

참고

[[자료구조] 간단히 알아보는 B-Tree, B+Tree, B*Tree](https://ssocoit.tistory.com/217)